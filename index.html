<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MWI Upgrade Cost Calculator</title>

  <!-- Terminal font -->
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#020617;
      --panel:#000;
      --border:rgba(34,197,94,.35);
      --border2:rgba(34,197,94,.2);
      --text:#86efac;
      --muted:#4ade80;
      --accent:#22c55e;
      --shadow:rgba(34,197,94,.25);

      --danger-bg:#3f1d1d;
      --danger-border:#7f1d1d;
      --danger-text:#fecaca;

      --coin:#fbbf24;
      --lumber:#22c55e;
      --log:#34d399;
      --arcane:#a78bfa;
      --ore:#93c5fd;
      --herb:#bef264;
      --food:#fb7185;
      --generic:#86efac;
    }

    *{ box-sizing:border-box; }

    body{
      font-family:"JetBrains Mono", monospace;
      background: radial-gradient(circle at top, #020617, #000);
      color:var(--text);
      margin:24px;
      max-width:1040px;
    }

    /* Subtle CRT scanlines */
    body::after{
      content:"";
      pointer-events:none;
      position:fixed;
      inset:0;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,.03),
        rgba(255,255,255,.03) 1px,
        transparent 1px,
        transparent 3px
      );
      opacity:.06;
    }

    h1{
      margin:0 0 10px;
      color:var(--accent);
      font-weight:600;
      text-shadow:0 0 10px var(--shadow);
      display:flex;
      align-items:center;
      gap:8px;
    }

    .cursor{
      display:inline-block;
      width:10px;
      color:var(--accent);
      animation: blink 1s steps(1) infinite;
      text-shadow:0 0 10px var(--shadow);
    }
    @keyframes blink{ 50%{ opacity:0; } }

    .muted{ color:var(--muted); font-size:12px; }

    .card{
      background: linear-gradient(180deg, rgba(0,0,0,.85), rgba(0,0,0,.6));
      border:1px solid var(--border);
      border-radius:14px;
      padding:14px;
      margin-top:14px;
      box-shadow: inset 0 0 0 1px rgba(34,197,94,.08), 0 0 18px rgba(34,197,94,.06);
    }

    .row{
      display:grid;
      gap:12px;
      grid-template-columns: 1.5fr 1fr 1fr;
      align-items:end;
    }

    label{
      display:block;
      font-size:12px;
      margin-bottom:6px;
      color:var(--muted);
    }

    select, input{
      width:100%;
      padding:10px;
      font-family:inherit;
      font-size:13px;
      background:var(--panel);
      color:var(--text);
      border:1px solid var(--border2);
      border-radius:10px;
      outline:none;
    }
    select:focus, input:focus{
      border-color:var(--accent);
      box-shadow:0 0 0 1px rgba(34,197,94,.35);
    }

    button{
      padding:10px 14px;
      font-family:inherit;
      font-size:13px;
      border-radius:10px;
      border:1px solid var(--border2);
      background:var(--panel);
      color:var(--accent);
      cursor:pointer;
      white-space:nowrap;
    }
    button:hover{
      background:rgba(34,197,94,.08);
      box-shadow:0 0 10px rgba(34,197,94,.22);
    }
    .btn{
      border-color:var(--accent);
      color:#000;
      background:var(--accent);
      font-weight:600;
    }
    .btn:hover{ background:#16a34a; }

    .pill{
      display:inline-block;
      padding:4px 10px;
      border-radius:999px;
      background:rgba(34,197,94,.15);
      color:var(--accent);
      font-size:11px;
    }

    .error{
      background:var(--danger-bg);
      border:1px solid var(--danger-border);
      color:var(--danger-text);
      padding:10px;
      border-radius:12px;
      margin-top:12px;
      font-size:13px;
    }

    .promptTitle{
      margin:18px 0 8px;
      color:var(--accent);
      font-weight:600;
      text-shadow:0 0 10px rgba(34,197,94,.25);
    }
    .promptTitle::before{
      content:"> ";
      color:var(--muted);
    }

    table{
      width:100%;
      border-collapse:collapse;
      margin-top:10px;
      font-size:13px;
    }
    th, td{
      padding:10px;
      border-bottom:1px dashed rgba(34,197,94,.22);
      vertical-align:top;
    }
    th{
      color:var(--muted);
      font-weight:600;
    }
    .right{ text-align:right; }

    .totalsGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    .totalLine{
      display:flex;
      justify-content:space-between;
      gap:12px;
      padding:10px;
      border:1px solid rgba(34,197,94,.18);
      border-radius:12px;
      background:rgba(0,0,0,.35);
    }
    .totalLine .label{ color:var(--muted); font-size:12px; }
    .totalLine .value{
      color:var(--accent);
      font-size:16px;
      font-weight:600;
      text-shadow:0 0 10px rgba(34,197,94,.25);
    }

    details summary{
      cursor:pointer;
      color:var(--accent);
      list-style:none;
    }
    details summary::-webkit-details-marker{ display:none; }
    details summary::before{
      content:"> ";
      color:var(--muted);
    }
    details[open] summary .chev{ transform:rotate(90deg); }
    .chev{
      display:inline-block;
      margin-right:6px;
      transition: transform .15s ease;
    }

    /* Resource color coding */
    .res-coin{ color:var(--coin); text-shadow:0 0 10px rgba(251,191,36,.18); }
    .res-lumber{ color:var(--lumber); }
    .res-log{ color:var(--log); }
    .res-arcane{ color:var(--arcane); text-shadow:0 0 10px rgba(167,139,250,.18); }
    .res-ore{ color:var(--ore); }
    .res-herb{ color:var(--herb); }
    .res-food{ color:var(--food); }
    .res-generic{ color:var(--generic); }

    /* Summary output box */
    .output{
      width:100%;
      min-height:150px;
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      border:1px solid var(--border2);
      background:#000;
      color:var(--text);
      font-family:inherit;
      font-size:12px;
      resize:vertical;
    }

    .hintRow{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
      margin-top:10px;
    }

    .kbd{
      border:1px solid rgba(34,197,94,.25);
      padding:2px 6px;
      border-radius:8px;
      color:var(--muted);
      font-size:11px;
      background:rgba(34,197,94,.06);
    }

    .marketRow{
      display:grid;
      gap:12px;
      grid-template-columns: 1fr 1fr 1fr;
      margin-top:12px;
      align-items:end;
    }

    .checkline{
      display:flex;
      gap:10px;
      align-items:center;
      padding:10px;
      border:1px solid rgba(34,197,94,.18);
      border-radius:12px;
      background:rgba(0,0,0,.35);
      height: 42px;
    }
    .checkline input{ width:auto; }
  </style>
</head>

<body>
  <h1>MWI Upgrade Cost Calculator <span class="cursor">▊</span></h1>
  <div class="muted">Choose a building tab, then pick current + target level. We sum only the levels you still need.</div>

  <div class="card">
    <div class="row">
      <div>
        <label for="sheet">Building / Tab</label>
        <select id="sheet"></select>
      </div>
      <div>
        <label for="currentLevel">Current Level</label>
        <input id="currentLevel" type="number" min="0" value="0" />
      </div>
      <div>
        <label for="targetLevel">Target Level</label>
        <input id="targetLevel" type="number" min="1" value="1" />
      </div>
    </div>

    <div style="display:flex; gap:10px; margin-top:12px; align-items:center; flex-wrap:wrap;">
      <button class="btn" id="calcBtn">Calculate</button>
      <button id="reloadBtn">Reload Tab Data</button>
      <span class="muted" id="status"></span>
    </div>

    <!-- Market pricing controls -->
    <div class="marketRow">
      <div class="checkline">
        <input type="checkbox" id="useMarket" />
        <span class="muted">Include Market Value (Coin)</span>
      </div>

      <div>
        <label for="marketSource">Market Source</label>
        <select id="marketSource">
          <option value="github_milkyapi" selected>GitHub (milkyapi.json) — recommended</option>
          <option value="github_marketapi">GitHub (marketapi.json)</option>
          <option value="github_median">GitHub (medianmarket.json)</option>
          <option value="official">Official (marketplace.json) — raw</option>
        </select>
      </div>

      <div>
        <label for="priceType">Price Type</label>
        <select id="priceType">
          <option value="ask">Ask</option>
          <option value="bid">Bid</option>
        </select>
      </div>
    </div>

    <div class="muted" style="margin-top:10px;">
      Tip: prefer milkyapi/marketapi/medianmarket for correct name-keyed lookups. (Official is HRID/raw and may be CORS-blocked on Pages.)
    </div>

    <div id="err" class="error" style="display:none;"></div>
  </div>

  <div class="card" id="results" style="display:none;">
    <div style="display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:10px;">
      <div>
        <div class="muted">Selected Range</div>
        <div id="rangeText" style="font-weight:600;"></div>
      </div>
      <div class="pill" id="rowsText"></div>
    </div>

    <div class="totalsGrid">
      <div class="totalLine">
        <div class="label">Grand Total (raw sums)</div>
        <div class="value" id="grandTotal">—</div>
      </div>
      <div class="totalLine">
        <div class="label">Grand Market Value (Coin)</div>
        <div class="value" id="grandValue">—</div>
      </div>
    </div>

    <div class="promptTitle">Terminal Output</div>
    <div class="hintRow">
      <div class="muted">
        Shortcuts:
        <span class="kbd">Enter</span> calculate
        <span class="kbd">Ctrl+K</span> focus building
        <span class="kbd">Ctrl+Enter</span> copy summary
      </div>
      <button id="copyBtn">Copy Summary</button>
    </div>
    <textarea id="summaryOut" class="output" readonly></textarea>

    <div class="promptTitle">Breakdown by Resource</div>
    <table>
      <thead>
        <tr>
          <th>Resource</th>
          <th class="right">Total Amount</th>
          <th class="right">Unit (Coin)</th>
          <th class="right">Value (Coin)</th>
        </tr>
      </thead>
      <tbody id="resourceRows"></tbody>
    </table>

    <details id="lineItemsDetails">
      <summary style="margin:18px 0 8px; font-weight:600;">
        <span class="chev">▶</span>
        Line Items <span class="muted" id="lineItemsHint"></span>
      </summary>

      <table>
        <thead>
          <tr>
            <th>Level</th>
            <th>Resource</th>
            <th class="right">Amount</th>
            <th class="right">Unit (Coin)</th>
            <th class="right">Value (Coin)</th>
          </tr>
        </thead>
        <tbody id="lineRows"></tbody>
      </table>
    </details>
  </div>

<script>
  // ======= CONFIG =======

  const SHEET_ID = "16Dcwa4OSYKn7emoca1aqoS-RGo_SeJEPHS2_yfC9iFs";

  const SHEETS = [
    "Skilling - Log Shed",
    "Skilling - Dairy Barn",
    "Skilling - Garden",
    "Skilling - Forge",
    "Skilling - Workshop",
    "Skilling - Sewing Parlor",
    "Skilling - Kitchen",
    "Skilling - Brewery",
    "Skilling - Laboratory",
    "Skilling - Observatory",
    "Combat - Dining Room",
    "Combat - Library",
    "Combat - Dojo",
    "Combat - Gym",
    "Combat - Armory",
    "Combat - Archery Range",
    "Combat - Mystical Study",
  ];

  // Prefer name-keyed feeds; keep official for completeness (raw/HRID keyed).
  const MARKET_URLS = {
    official: "https://www.milkywayidle.com/game_data/marketplace.json",
    github_milkyapi: "https://raw.githubusercontent.com/holychikenz/MWIApi/refs/heads/main/milkyapi.json",
    github_marketapi: "https://raw.githubusercontent.com/holychikenz/MWIApi/main/marketapi.json",
    github_median: "https://raw.githubusercontent.com/holychikenz/MWIApi/main/medianmarket.json",
  };

  // ======= ELEMENTS =======

  const els = {
    sheet: document.getElementById("sheet"),
    currentLevel: document.getElementById("currentLevel"),
    targetLevel: document.getElementById("targetLevel"),
    calcBtn: document.getElementById("calcBtn"),
    reloadBtn: document.getElementById("reloadBtn"),
    status: document.getElementById("status"),
    err: document.getElementById("err"),

    useMarket: document.getElementById("useMarket"),
    marketSource: document.getElementById("marketSource"),
    priceType: document.getElementById("priceType"),

    results: document.getElementById("results"),
    rangeText: document.getElementById("rangeText"),
    rowsText: document.getElementById("rowsText"),
    grandTotal: document.getElementById("grandTotal"),
    grandValue: document.getElementById("grandValue"),
    resourceRows: document.getElementById("resourceRows"),
    lineRows: document.getElementById("lineRows"),

    copyBtn: document.getElementById("copyBtn"),
    summaryOut: document.getElementById("summaryOut"),

    lineItemsDetails: document.getElementById("lineItemsDetails"),
    lineItemsHint: document.getElementById("lineItemsHint"),
  };

  // ======= STATE =======

  let loaded = { sheetName: null, maxLevel: 0, levels: {} };

  let marketData = null;
  let marketIndex = null;        // case/space-insensitive index
  let marketSourceLoaded = null; // actual loaded source (after fallback)

  // ======= HELPERS =======

  function setStatus(msg) { els.status.textContent = msg || ""; }
  function showError(msg) { els.err.style.display = "block"; els.err.textContent = msg; }
  function clearError() { els.err.style.display = "none"; els.err.textContent = ""; }

  function formatNumber(n) {
    return n.toLocaleString(undefined, { maximumFractionDigits: 0 });
  }

  function formatCoin(n) {
    return n.toLocaleString(undefined, { maximumFractionDigits: 0 });
  }

  function normKey(s) {
    return String(s ?? "")
      .trim()
      .replace(/\s+/g, " ")
      .toLowerCase();
  }

  function buildMarketIndex(data) {
    const idx = new Map();
    for (const [name, entry] of Object.entries(data?.market || {})) {
      idx.set(normKey(name), entry);
    }
    return idx;
  }

  function resourceClass(resourceName) {
    const r = String(resourceName || "").toLowerCase();
    if (r.includes("coin")) return "res-coin";
    if (r.includes("lumber")) return "res-lumber";
    if (r.includes("log")) return "res-log";
    if (r.includes("arcane")) return "res-arcane";
    if (r.includes("ore") || r.includes("bar") || r.includes("ingot")) return "res-ore";
    if (r.includes("herb") || r.includes("leaf") || r.includes("root")) return "res-herb";
    if (r.includes("bread") || r.includes("cheese") || r.includes("stew") || r.includes("meal") || r.includes("milk")) return "res-food";
    return "res-generic";
  }

  // Google Visualization fetch (public/viewable sheets)
  function gvizUrl(sheetName) {
    const base = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq`;
    const params = new URLSearchParams({ tqx: "out:json", sheet: sheetName });
    return `${base}?${params.toString()}`;
  }

  function parseGvizJson(text) {
    const start = text.indexOf("{");
    const end = text.lastIndexOf("}");
    if (start === -1 || end === -1) throw new Error("Unexpected gviz response.");
    return JSON.parse(text.slice(start, end + 1));
  }

  function toCellString(cell) {
    if (!cell) return "";
    if (cell.f != null) return String(cell.f);
    if (cell.v != null) return String(cell.v);
    return "";
  }

  // Parse "500,000 Coin" / "-9 Cheese Hatchet" / "-"
  function parseCellToItem(cellText) {
    const s = String(cellText || "").trim();
    if (!s || s === "-" || s === "—") return null;

    const m = s.match(/^(-?\d[\d,]*)(?:\s+(.+))?$/);
    if (!m) return null;

    const amount = Number(m[1].replace(/,/g, ""));
    if (!Number.isFinite(amount)) return null;

    const resource = (m[2] || "").trim();
    if (!resource) return null;

    return { amount, resource };
  }

  function marketCacheKey(source) {
    return `mwi_market_${source}_v2`;
  }

  async function fetchJson(url) {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return await res.json();
  }

  async function loadMarketData(source) {
    // 10 minute cache
    const key = marketCacheKey(source);
    const cached = localStorage.getItem(key);
    if (cached) {
      try {
        const obj = JSON.parse(cached);
        if (obj?.ts && (Date.now() - obj.ts) < 10 * 60 * 1000 && obj.data) {
          const data = obj.data;
          if (data.market && typeof data.market === "object") {
            return { data, idx: buildMarketIndex(data) };
          }
        }
      } catch {}
    }

    const url = MARKET_URLS[source];
    const data = await fetchJson(url);

    if (!data || typeof data !== "object") throw new Error("Bad JSON");

    // Name-keyed feeds should include `market`.
    if (!data.market || typeof data.market !== "object") throw new Error("Missing `market` object");

    // Ensure Coin exists
    if (!data.market.Coin) data.market.Coin = { ask: 1, bid: 1 };

    const idx = buildMarketIndex(data);

    localStorage.setItem(key, JSON.stringify({ ts: Date.now(), data }));
    return { data, idx };
  }

  function getItemPriceCoin(itemName, priceType) {
    const entry = marketIndex?.get(normKey(itemName));
    const p = entry?.[priceType];

    if (p === undefined || p === null) return null;
    if (p === -1) return null;
    if (!Number.isFinite(p)) return null;
    return p;
  }

  async function ensureMarketLoaded(preferredSource) {
    if (marketData && marketSourceLoaded === preferredSource && marketIndex) return;

    // Prefer name-keyed sources first, fallback to others
    const attempts = [
      preferredSource,
      "github_milkyapi",
      "github_marketapi",
      "github_median",
      "official",
    ].filter((v, i, arr) => arr.indexOf(v) === i);

    let lastErr = null;

    for (const src of attempts) {
      try {
        const { data, idx } = await loadMarketData(src);

        // If "official" looks HRID/raw, reject it (needs formatting)
        if (src === "official" && data?.marketData && !data?.market?.["Holy Milk"]) {
          throw new Error("Official market feed appears HRID-keyed; use a GitHub source instead.");
        }

        marketData = data;
        marketIndex = idx;
        marketSourceLoaded = src;
        return;
      } catch (e) {
        lastErr = e;
      }
    }

    throw new Error(`Market load failed: ${lastErr?.message || lastErr || "unknown error"}`);
  }

  function buildSummaryText({ sheetName, fromLevel, toLevel, current, items, byResource, grand, includeMarket, priceType, marketSource, byResourceValue, grandValue }) {
    const lines = [];
    lines.push(`> ${sheetName}`);
    lines.push(`> Range: L${fromLevel} -> L${toLevel} (current: L${current})`);
    lines.push(`> Items: ${items.length}`);
    lines.push(`> ------------------------------`);
    lines.push(`> Breakdown:`);

    const sorted = [...byResource.entries()].sort((a,b) => b[1]-a[1]);
    for (const [res, total] of sorted) {
      const maybeVal = includeMarket ? byResourceValue.get(res) : null;
      const maybeUnit = includeMarket ? (byResourceValue.get(res) != null && (byResource.get(res) || 0) !== 0 ? (maybeVal / total) : null) : null;

      if (includeMarket) {
        lines.push(`  - ${res}: ${formatNumber(total)} | unit: ${maybeUnit != null ? formatCoin(maybeUnit) : "-"} | value: ${maybeVal != null ? formatCoin(maybeVal) : "-"}`);
      } else {
        lines.push(`  - ${res}: ${formatNumber(total)}`);
      }
    }

    lines.push(`> ------------------------------`);
    lines.push(`> Grand Total: ${formatNumber(grand)}`);

    if (includeMarket) {
      lines.push(`> Market Value (${priceType}, ${marketSource}): ${grandValue != null ? formatCoin(grandValue) : "-"}`);
    }

    lines.push(`>`);
    lines.push(`> Line Items:`);

    for (const it of items) {
      const res = String(it.resource);
      if (includeMarket) {
        lines.push(`  L${it.level}  ${res.padEnd(22, " ")}  ${formatNumber(it.amount)} | unit: ${it.unitCoin != null ? formatCoin(it.unitCoin) : "-"} | ${it.valueCoin != null ? formatCoin(it.valueCoin) : "-"}`);
      } else {
        lines.push(`  L${it.level}  ${res.padEnd(22, " ")}  ${formatNumber(it.amount)}`);
      }
    }

    return lines.join("\n");
  }

  async function copyToClipboard(text) {
    await navigator.clipboard.writeText(text);
  }

  // ======= LOAD SHEET TAB =======

  async function loadTab(sheetName) {
    clearError();
    setStatus(`Loading "${sheetName}"…`);

    const res = await fetch(gvizUrl(sheetName), { cache: "no-store" });
    if (!res.ok) throw new Error(`Failed to fetch "${sheetName}". (Is the tab name correct?)`);

    const raw = await res.text();
    const json = parseGvizJson(raw);

    const table = json.table;
    if (!table || !table.cols || !table.rows) throw new Error(`No table data returned for "${sheetName}".`);

    // Each column = one level
    const maxLevel = table.cols.length;

    const levels = {};
    for (let lvl = 1; lvl <= maxLevel; lvl++) levels[lvl] = [];

    for (const r of table.rows) {
      const c = r.c || [];
      for (let lvl = 1; lvl <= maxLevel; lvl++) {
        const cellText = toCellString(c[lvl - 1]);
        const item = parseCellToItem(cellText);
        if (!item) continue;
        levels[lvl].push(item);
      }
    }

    loaded = { sheetName, maxLevel, levels };
    setStatus(`Loaded "${sheetName}" (max level: ${maxLevel}).`);

    // Clamp inputs
    const cur = Number(els.currentLevel.value) || 0;
    const tgt = Number(els.targetLevel.value) || 1;
    if (tgt > maxLevel) els.targetLevel.value = String(maxLevel);
    if (cur > maxLevel) els.currentLevel.value = String(maxLevel);
  }

  // ======= CALCULATE / RENDER =======

  async function calculate() {
    clearError();
    setStatus("");

    if (!loaded.sheetName) return showError("Load a tab first.");

    const current = Number(els.currentLevel.value);
    const target = Number(els.targetLevel.value);

    if (!Number.isFinite(current) || current < 0) return showError("Current level must be 0 or higher.");
    if (!Number.isFinite(target) || target < 1) return showError("Target level must be 1 or higher.");
    if (target <= current) return showError("Target level must be higher than current level.");
    if (target > loaded.maxLevel) return showError(`Target level can't exceed ${loaded.maxLevel} for this tab.`);

    const fromLevel = current + 1;
    const toLevel = target;

    const items = [];
    for (let lvl = fromLevel; lvl <= toLevel; lvl++) {
      for (const it of (loaded.levels[lvl] || [])) {
        items.push({
          level: lvl,
          amount: it.amount,
          resource: it.resource,
          unitCoin: null,
          valueCoin: null
        });
      }
    }

    if (items.length === 0) return showError(`No items found for levels ${fromLevel}-${toLevel}.`);

    // Amount breakdown
    const byResource = new Map();
    let grand = 0;
    for (const it of items) {
      grand += it.amount;
      byResource.set(it.resource, (byResource.get(it.resource) || 0) + it.amount);
    }

    // Market values
    const includeMarket = !!els.useMarket.checked;
    const preferredSource = els.marketSource.value;
    const priceType = els.priceType.value;

    const byResourceValue = new Map();
    const byResourceUnit = new Map();
    let grandValue = null;

    if (includeMarket) {
      try {
        setStatus("Loading market prices…");
        await ensureMarketLoaded(preferredSource);
        setStatus(`Market loaded (${marketSourceLoaded}, ${priceType}).`);

        let gv = 0;

        for (const it of items) {
          const unit = getItemPriceCoin(it.resource, priceType);
          it.unitCoin = unit;

          if (unit == null) {
            it.valueCoin = null;
            continue;
          }

          const v = it.amount * unit;
          it.valueCoin = v;

          gv += v;
          byResourceValue.set(it.resource, (byResourceValue.get(it.resource) || 0) + v);
        }

        // compute implied per-resource unit (total value / total amount) where possible
        for (const [res, totalAmt] of byResource.entries()) {
          const totalVal = byResourceValue.get(res);
          if (totalVal != null && totalAmt) byResourceUnit.set(res, totalVal / totalAmt);
        }

        grandValue = gv;

      } catch (e) {
        setStatus(`Market pricing unavailable: ${e.message || e}`);
        grandValue = null;
      }
    } else {
      grandValue = null;
    }

    // Render header
    els.results.style.display = "block";
    els.rangeText.textContent = `${loaded.sheetName} — Levels ${fromLevel} → ${toLevel} (current: ${current})`;
    els.rowsText.textContent = `${items.length} line item(s)`;
    els.grandTotal.textContent = formatNumber(grand);
    els.grandValue.textContent = includeMarket ? (grandValue != null ? formatCoin(grandValue) : "-") : "-";
    els.lineItemsHint.textContent = `(${items.length})`;

    // Breakdown table
    els.resourceRows.innerHTML = "";
    [...byResource.entries()]
      .sort((a,b) => b[1] - a[1])
      .forEach(([resource, total]) => {
        const unit = includeMarket ? byResourceUnit.get(resource) : null;
        const val = includeMarket ? byResourceValue.get(resource) : null;

        const tr = document.createElement("tr");
        tr.innerHTML =
          `<td><span class="${resourceClass(resource)}">${resource}</span></td>
           <td class="right">${formatNumber(total)}</td>
           <td class="right">${includeMarket ? (unit != null ? formatCoin(unit) : "-") : "-"}</td>
           <td class="right">${includeMarket ? (val != null ? formatCoin(val) : "-") : "-"}</td>`;
        els.resourceRows.appendChild(tr);
      });

    // Line items table
    els.lineRows.innerHTML = "";
    items.forEach((it) => {
      const tr = document.createElement("tr");
      tr.innerHTML =
        `<td>${it.level}</td>
         <td><span class="${resourceClass(it.resource)}">${it.resource}</span></td>
         <td class="right">${formatNumber(it.amount)}</td>
         <td class="right">${includeMarket ? (it.unitCoin != null ? formatCoin(it.unitCoin) : "-") : "-"}</td>
         <td class="right">${includeMarket ? (it.valueCoin != null ? formatCoin(it.valueCoin) : "-") : "-"}</td>`;
      els.lineRows.appendChild(tr);
    });

    // Terminal output
    els.summaryOut.value = buildSummaryText({
      sheetName: loaded.sheetName,
      fromLevel,
      toLevel,
      current,
      items,
      byResource,
      grand,
      includeMarket,
      priceType,
      marketSource: marketSourceLoaded || preferredSource,
      byResourceValue,
      grandValue
    });
  }

  // ======= UI INIT / EVENTS =======

  function initSheetSelect() {
    els.sheet.innerHTML = "";
    SHEETS.forEach(name => {
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      els.sheet.appendChild(opt);
    });
  }

  els.reloadBtn.addEventListener("click", async () => {
    try { await loadTab(els.sheet.value); }
    catch (e) { setStatus(""); showError(e.message || String(e)); }
  });

  els.calcBtn.addEventListener("click", () => calculate());

  els.copyBtn.addEventListener("click", async () => {
    try {
      await copyToClipboard(els.summaryOut.value || "");
      setStatus("Copied summary to clipboard.");
      setTimeout(() => setStatus(""), 1200);
    } catch (e) {
      showError("Copy failed. Your browser may be blocking clipboard access.");
    }
  });

  // Keyboard shortcuts:
  // Enter = calculate (unless focused in textarea)
  // Ctrl+K = focus building dropdown
  // Ctrl+Enter = copy summary
  document.addEventListener("keydown", async (e) => {
    const key = e.key.toLowerCase();

    if (e.ctrlKey && key === "k") {
      e.preventDefault();
      els.sheet.focus();
      return;
    }

    if (!e.ctrlKey && e.key === "Enter") {
      if (document.activeElement && document.activeElement.tagName === "TEXTAREA") return;
      e.preventDefault();
      await calculate();
      return;
    }

    if (e.ctrlKey && e.key === "Enter") {
      e.preventDefault();
      try {
        await copyToClipboard(els.summaryOut.value || "");
        setStatus("Copied summary to clipboard.");
        setTimeout(() => setStatus(""), 1200);
      } catch (err) {
        showError("Copy failed. Your browser may be blocking clipboard access.");
      }
    }
  });

  // Initialize
  (async function boot() {
    initSheetSelect();
    try { await loadTab(els.sheet.value); }
    catch (e) { setStatus(""); showError(e.message || String(e)); }
  })();
</script>
</body>
</html>
